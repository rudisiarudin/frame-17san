<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Twibbon Maker — Vanilla HTML</title>
<style>
  :root { color-scheme: light; }
  * { box-sizing: border-box; }
  body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; color: #111; background: #fafafa; }
  .container { max-width: 1120px; margin: 0 auto; padding: 16px 24px; }
  h1 { margin: 0 0 6px; font-size: 24px; }
  p.sub { margin: 0; color: #555; font-size: 13px; }
  .grid { display: grid; grid-template-columns: 1fr; gap: 24px; }
  @media (min-width: 1024px) { .grid { grid-template-columns: 2fr 1fr; } }
  .card { background: #fff; border: 1px solid #e5e5e5; border-radius: 16px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
  .pad { padding: 16px; }
  .row { display: flex; gap: 8px; align-items: center; }
  .row.wrap { flex-wrap: wrap; }
  .spacer { flex: 1 1 auto; }
  .btn { appearance: none; border: 1px solid #e5e5e5; background: #fff; padding: 8px 12px; border-radius: 12px; font-size: 13px; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,.04); display: inline-flex; gap: 6px; align-items: center; }
  .btn:hover { box-shadow: 0 2px 6px rgba(0,0,0,.06); }
  .btn[disabled] { opacity: .5; cursor: default; }
  .btn.primary { background: #111; color: #fff; border-color: #111; }
  .select { padding: 8px 10px; border: 1px solid #e5e5e5; border-radius: 12px; background: #fff; font-size: 13px; }
  .small { font-size: 12px; color: #666; }
  .wrap { position: relative; width: 100%; border-radius: 16px; overflow: hidden; }
  #wrap { aspect-ratio: 1 / 1; background: #fff; }
  #preview { position: absolute; inset: 0; width: 100%; height: 100%; touch-action: none; cursor: grab; }
  #preview:active { cursor: grabbing; }
  .hud { position: absolute; left: 12px; top: 12px; display: flex; gap: 8px; }
  .chip { background: rgba(255,255,255,.85); -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); border: 1px solid #e5e5e5; padding: 4px 8px; border-radius: 10px; font-size: 11px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
  .hud2 { position: absolute; right: 12px; top: 12px; }
  .thumbs { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
  .thumb { position: relative; aspect-ratio: 1 / 1; border: 1px solid #e5e5e5; border-radius: 12px; overflow: hidden; padding: 0; background: #fff; }
  .thumb img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
  .thumb.active { outline: 2px solid #111; }
  .mt8 { margin-top: 8px; } .mt12 { margin-top: 12px; } .mt16 { margin-top: 16px; }
  .col { display: grid; gap: 12px; }
  .info ul { margin: 8px 0 0; padding: 0 0 0 18px; }
  .info li { margin: 4px 0; font-size: 13px; color: #333; }
  svg { width: 16px; height: 16px; }
</style>
</head>
<body>
  <div class="container">
    <header class="row" style="justify-content: space-between; margin-bottom: 12px;">
      <div>
        <h1>Twibbon Maker — Vanilla HTML</h1>
        <p class="sub">Upload frame PNG transparan + foto, atur posisi, lalu unduh PNG akhir. Semua proses di browser (tanpa framework).</p>
      </div>
      <div class="row" style="display:none" id="headerBtns"></div>
    </header>

    <div class="grid">
      <section class="card pad">
        <div id="wrap" class="wrap">
          <canvas id="preview"></canvas>
          <div class="hud" id="hudLeft">
            <span class="chip" id="designChip">1080×1080 design</span>
            <span class="chip" id="zoomChip" style="display:none">Zoom 100%</span>
          </div>
          <div class="hud2">
            <button class="btn small" id="gridBtn">Grid</button>
          </div>
        </div>
        <div class="row wrap mt12">
          <button class="btn" id="zoomInBtn">"+iconPlus()+" Zoom in</button>
          <button class="btn" id="zoomOutBtn">"+iconMinus()+" Zoom out</button>
          <button class="btn" id="centerBtn">"+iconCrosshair()+" Center</button>
          <div class="spacer"></div>
          <label class="small" for="exportSize">Export:</label>
          <select id="exportSize" class="select">
            <option value="720">720 px</option>
            <option value="1080" selected>1080 px</option>
            <option value="1440">1440 px</option>
            <option value="2048">2048 px</option>
            <option value="3000">3000 px</option>
          </select>
          <button class="btn primary" id="downloadBtn">"+iconDownload()+" Download PNG</button>
        </div>
        <div class="row wrap mt8">
          <button class="btn" id="fitBtn">"+iconFit()+" Fit</button>
          <button class="btn" id="resetBtn">"+iconReset()+" Reset</button>
        </div>
      </section>

      <aside class="col">
        <section class="card pad">
          <h3 style="margin:0 0 10px;">Upload</h3>
          <div class="col">
            <label>
              <div class="small">Frame PNG (bisa multi file)</div>
              <input type="file" accept="image/png" id="frameInput" multiple />
            </label>
            <label>
              <div class="small">Foto</div>
              <input type="file" accept="image/*" id="photoInput" />
            </label>
          </div>
        </section>

        <section class="card pad">
          <h3 style="margin:0 0 10px;">Frame</h3>
          <div id="thumbs" class="thumbs"></div>
          <div class="row mt12">
            <button class="btn" id="removeFrameBtn">"+iconTrash()+" Hapus terpilih</button>
            <button class="btn" id="fitPhotoBtn">Fit foto ke kanvas</button>
          </div>
        </section>

        <section class="card pad info">
          <h3 style="margin:0 0 10px;">Info</h3>
          <ul>
            <li>Gunakan PNG frame dengan transparansi agar foto terlihat di belakang frame.</li>
            <li>Zoom dengan scroll/pinch. Drag di kanvas untuk geser.</li>
            <li>Hasil download dalam PNG (background transparan) dengan resolusi sesuai pilihan.</li>
          </ul>
        </section>
      </aside>
    </div>
  </div>

<script>
(function(){
  const state = {
    designW: 1080,
    designH: 1080,
    photo: null, // {img,w,h,src,name}
    frames: [], // [{img,w,h,src,name}]
    activeFrameIdx: -1,
    offset: {x:0, y:0},
    zoom: 1,
    exportSize: 1080,
    showGrid: false,
  };

  // Elements
  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('preview');
  const ctx = canvas.getContext('2d');
  const designChip = document.getElementById('designChip');
  const zoomChip = document.getElementById('zoomChip');
  const gridBtn = document.getElementById('gridBtn');
  const thumbsEl = document.getElementById('thumbs');
  const frameInput = document.getElementById('frameInput');
  const photoInput = document.getElementById('photoInput');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const centerBtn = document.getElementById('centerBtn');
  const fitBtn = document.getElementById('fitBtn');
  const resetBtn = document.getElementById('resetBtn');
  const exportSizeSel = document.getElementById('exportSize');
  const downloadBtn = document.getElementById('downloadBtn');
  const removeFrameBtn = document.getElementById('removeFrameBtn');
  const fitPhotoBtn = document.getElementById('fitPhotoBtn');

  // Utility
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const coverScale = (pw,ph,dw,dh)=>Math.max(dw/pw, dh/ph);
  const computeExportHeight = (dw,dh,w)=>Math.round((dh/dw)*w);

  function drawChecker(g, w, h, size=16){
    g.save();
    const s = size;
    g.fillStyle = '#f5f5f5'; g.fillRect(0,0,w,h);
    g.fillStyle = '#e5e5e5';
    for (let y=0;y<h;y+=s){
      for (let x=0;x<w;x+=s){ if (((x+y)/s)%2<1) g.fillRect(x,y,s,s); }
    }
    g.restore();
  }
  function drawGrid(g,W,H){
    g.save();
    g.strokeStyle='rgba(0,0,0,.18)'; g.lineWidth=1;
    const thirds=[W/3,2*W/3];
    thirds.forEach(x=>{g.beginPath();g.moveTo(x,0);g.lineTo(x,H);g.stroke();});
    thirds.forEach(y=>{g.beginPath();g.moveTo(0,y);g.lineTo(W,y);g.stroke();});
    g.strokeStyle='rgba(0,0,0,.12)'; g.setLineDash([6,6]); g.strokeRect(16,16,W-32,H-32);
    g.restore();
  }

  // Derived
  function baseCover(){
    if(!state.photo) return 1;
    return coverScale(state.photo.w, state.photo.h, state.designW, state.designH);
  }

  // Resize logic
  function resizeCanvas(){
    wrap.style.aspectRatio = `${state.designW} / ${state.designH}`;
    const dpr = Math.min(window.devicePixelRatio||1,2);
    const width = wrap.clientWidth;
    const height = Math.max(320, Math.round(width * (state.designH / state.designW)));
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    canvas.width = Math.round(width * dpr);
    canvas.height = Math.round(height * dpr);
    draw();
  }

  const ro = new ResizeObserver(resizeCanvas); ro.observe(wrap);

  // Drawing
  function draw(){
    // reset & clear device pixels
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    drawChecker(ctx, canvas.width, canvas.height, 16*(window.devicePixelRatio||1));

    // scale to CSS px then to design units
    const dpr = Math.min(window.devicePixelRatio||1,2);
    const cssW = canvas.clientWidth; const cssH = canvas.clientHeight;
    const kx = cssW / state.designW; const ky = cssH / state.designH;
    ctx.scale(dpr,dpr); ctx.scale(kx,ky);

    // photo
    if(state.photo){
      const scale = baseCover() * state.zoom;
      const dw = state.photo.w * scale; const dh = state.photo.h * scale;
      const x = state.designW/2 + state.offset.x - dw/2;
      const y = state.designH/2 + state.offset.y - dh/2;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(state.photo.img, x, y, dw, dh);
    }

    if(state.showGrid) drawGrid(ctx, state.designW, state.designH);

    if(state.activeFrameIdx>=0 && state.frames[state.activeFrameIdx]){
      const f = state.frames[state.activeFrameIdx];
      ctx.drawImage(f.img, 0, 0, state.designW, state.designH);
    }

    designChip.textContent = `${Math.round(state.designW)}×${Math.round(state.designH)} design`;
    if(state.photo){
      zoomChip.style.display = '';
      zoomChip.textContent = `Zoom ${Math.round(state.zoom*100)}%`;
    } else { zoomChip.style.display = 'none'; }
  }

  // Loaders
  async function loadImageFromFile(file){
    const objectUrl = URL.createObjectURL(file);
    if (typeof createImageBitmap === 'function'){
      try {
        const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
        return { img: bmp, w: bmp.width, h: bmp.height, src: objectUrl, name: file.name };
      } catch(e) { /* fallback */ }
    }
    // Fallback
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.onload = ()=>resolve({ img, w: img.naturalWidth, h: img.naturalHeight, src: objectUrl, name: file.name });
      img.onerror = reject; img.src = objectUrl;
    });
  }

  async function onPhotoChange(e){
    const file = e.target.files && e.target.files[0]; if(!file) return;
    const p = await loadImageFromFile(file);
    state.photo = p; state.offset={x:0,y:0}; state.zoom=1; draw();
  }
  async function onFrameChange(e){
    const files = Array.from(e.target.files||[]); if(!files.length) return;
    const imgs = await Promise.all(files.map(loadImageFromFile));
    state.frames = state.frames.concat(imgs);
    if(state.activeFrameIdx===-1) state.activeFrameIdx = state.frames.length - imgs.length; // first of new
    rebuildThumbs();
    // If first time / or size changed, adopt frame size and re-center
    const f = state.frames[state.activeFrameIdx];
    if (f){ state.designW=f.w; state.designH=f.h; state.offset={x:0,y:0}; state.zoom=1; }
    resizeCanvas();
  }

  // Thumbnails
  function rebuildThumbs(){
    thumbsEl.innerHTML = '';
    state.frames.forEach((f,i)=>{
      const btn = document.createElement('button'); btn.className='thumb'+(i===state.activeFrameIdx?' active':'');
      btn.title = f.name || 'Frame';
      const img = document.createElement('img'); img.src = f.src; btn.appendChild(img);
      btn.addEventListener('click', ()=>{ state.activeFrameIdx=i; const ff=state.frames[i]; if(ff){ state.designW=ff.w; state.designH=ff.h; state.offset={x:0,y:0}; state.zoom=1; resizeCanvas(); } rebuildThumbs(); });
      thumbsEl.appendChild(btn);
    });
  }

  // Pointer interactions
  const drag = { on:false, lastX:0, lastY:0 };
  canvas.addEventListener('pointerdown', (ev)=>{ canvas.setPointerCapture?.(ev.pointerId); drag.on=true; drag.lastX=ev.clientX; drag.lastY=ev.clientY; });
  canvas.addEventListener('pointermove', (ev)=>{
    if(!drag.on) return; const cssW=canvas.clientWidth, cssH=canvas.clientHeight;
    const kx=cssW/state.designW, ky=cssH/state.designH;
    const dx=(ev.clientX-drag.lastX)/kx; const dy=(ev.clientY-drag.lastY)/ky;
    drag.lastX=ev.clientX; drag.lastY=ev.clientY; state.offset.x+=dx; state.offset.y+=dy; draw();
  });
  canvas.addEventListener('pointerup', (ev)=>{ try{ canvas.releasePointerCapture?.(ev.pointerId); }catch{} drag.on=false; });
  canvas.addEventListener('pointercancel', ()=>{ drag.on=false; });
  canvas.addEventListener('wheel', (ev)=>{
    ev.preventDefault(); const delta = -ev.deltaY; const factor = Math.exp(delta*0.0015);
    const rect=canvas.getBoundingClientRect(); const cssX=ev.clientX-rect.left; const cssY=ev.clientY-rect.top;
    const kx=canvas.clientWidth/state.designW, ky=canvas.clientHeight/state.designH;
    const dx=cssX/kx, dy=cssY/ky;
    state.offset.x=(state.offset.x-dx)*factor+dx; state.offset.y=(state.offset.y-dy)*factor+dy;
    state.zoom = clamp(state.zoom*factor, 0.2, 8);
    draw();
  }, { passive:false });

  // Controls
  zoomInBtn.addEventListener('click', ()=>{ state.zoom=clamp(state.zoom*1.1,0.2,8); draw(); });
  zoomOutBtn.addEventListener('click', ()=>{ state.zoom=clamp(state.zoom/1.1,0.2,8); draw(); });
  centerBtn.addEventListener('click', ()=>{ state.offset={x:0,y:0}; draw(); });
  fitBtn.addEventListener('click', ()=>{ state.offset={x:0,y:0}; state.zoom=1; draw(); });
  resetBtn.addEventListener('click', ()=>{ state.offset={x:0,y:0}; state.zoom=1; state.frames=[]; state.activeFrameIdx=-1; rebuildThumbs(); state.designW=1080; state.designH=1080; resizeCanvas(); });
  gridBtn.addEventListener('click', ()=>{ state.showGrid=!state.showGrid; gridBtn.classList.toggle('primary', state.showGrid); draw(); });
  exportSizeSel.addEventListener('change', ()=>{ state.exportSize = Number(exportSizeSel.value)||1080; });
  downloadBtn.addEventListener('click', ()=>{ exportPNG(); });
  removeFrameBtn.addEventListener('click', ()=>{
    if(state.activeFrameIdx<0) return; state.frames.splice(state.activeFrameIdx,1);
    if(state.frames.length){ state.activeFrameIdx = Math.max(0, state.activeFrameIdx-1); const f=state.frames[state.activeFrameIdx]; state.designW=f.w; state.designH=f.h; }
    else { state.activeFrameIdx=-1; state.designW=1080; state.designH=1080; }
    rebuildThumbs(); resizeCanvas();
  });
  fitPhotoBtn.addEventListener('click', ()=>{ if(!state.photo) return; state.offset={x:0,y:0}; state.zoom=1; draw(); });

  frameInput.addEventListener('change', onFrameChange);
  photoInput.addEventListener('change', onPhotoChange);

  // Export
  function exportPNG(){
    const width = state.exportSize; const height = computeExportHeight(state.designW, state.designH, width);
    const out = document.createElement('canvas'); out.width = width; out.height = height; const g = out.getContext('2d');
    const k = width / state.designW; g.save(); g.scale(k,k);
    if(state.photo){
      const scale = baseCover() * state.zoom; const dw=state.photo.w*scale, dh=state.photo.h*scale;
      const x=state.designW/2 + state.offset.x - dw/2; const y=state.designH/2 + state.offset.y - dh/2;
      g.imageSmoothingQuality='high'; g.drawImage(state.photo.img, x, y, dw, dh);
    }
    if(state.activeFrameIdx>=0 && state.frames[state.activeFrameIdx]){
      const f=state.frames[state.activeFrameIdx]; g.drawImage(f.img, 0, 0, state.designW, state.designH);
    }
    g.restore();
    out.toBlob((blob)=>{ if(!blob) return; const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`twibbon-${width}x${height}.png`; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500); }, 'image/png');
  }

  // Initial layout
  resizeCanvas();
  runSelfTests();

  // ---- Lightweight Self Tests (console only) ----
  function runSelfTests(){
    try{
      let passed=0, failed=0; const t=(name,cond)=>{ if(cond){passed++;} else {failed++; console.error('[Test FAIL]', name);} };
      // clamp
      t('clamp lower bound', (function(){return clamp(-5,0,10)===0;})());
      t('clamp upper bound', clamp(15,0,10)===10);
      t('clamp middle', clamp(5,0,10)===5);
      t('clamp min boundary', clamp(0.1,0.2,8)===0.2);
      t('clamp max boundary', clamp(10,0.2,8)===8);

      // export height
      t('export height 1:1', computeExportHeight(1000,1000,1080)===1080);
      t('export height 16:9', computeExportHeight(1600,900,1600)===900);
      t('export height 9:16', computeExportHeight(900,1600,900)===1600);
      t('export height rounding', computeExportHeight(3,2,1001)===667);

      // cover scale
      t('cover wider photo', coverScale(2000,1000,1000,1000)===1);
      t('cover taller photo', coverScale(1000,2000,1000,1000)===1);
      t('cover equal ratio = 2', coverScale(1000,1000,2000,2000)===2);
      t('cover needs up-scale', Math.abs(coverScale(800,800,1000,1000)-1.25)<1e-6);

      // DPR mapping sanity (no exceptions)
      const testCanvas=document.createElement('canvas'); const dpr=2, cssW=300, cssH=150; testCanvas.width=cssW*dpr; testCanvas.height=cssH*dpr; const g=testCanvas.getContext('2d');
      g.setTransform(1,0,0,1,0,0); g.scale(dpr,dpr); g.scale(cssW/100, cssH/50); g.fillRect(0,0,100,50);
      t('mapping finite', Number.isFinite(testCanvas.width) && Number.isFinite(testCanvas.height));

      const summary=`[Twibbon Maker tests] passed=${passed}, failed=${failed}`; if(failed===0) console.info(summary); else console.warn(summary);
    }catch(err){ console.warn('Self-tests encountered an error:', err); }
  }
})();

// ---- Icons (tiny inline SVGs) ----
function iconPlus(){return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg>';}
function iconMinus(){return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/></svg>';}
function iconCrosshair(){return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 2v4M12 18v4M2 12h4M18 12h4"/></svg>';}
function iconDownload(){return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="M7 10l5 5 5-5"/><path d="M12 15V3"/></svg>';}
function iconFit(){return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7V3h4"/><path d="M21 7V3h-4"/><path d="M21 17v4h-4"/><path d="M3 17v4h4"/></svg>';}
function iconReset(){return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9 9 0 0 0-9 9Z"/><path d="M3 3v6h6"/></svg>';}
function iconTrash(){return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/></svg>';}
</script>
</body>
</html>
